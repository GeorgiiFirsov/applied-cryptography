\documentclass[12pt, a4paper]{extarticle}


% Russian text support
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

% Some useful packages
\usepackage{indentfirst}
\usepackage{etoolbox}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{xcolor}

% Page geometry
\usepackage[
    left=3cm,
    right=1cm,
    top=2cm,
    bottom=2cm
]{geometry}

% Make titles not to have numbering
\newenvironment*{dummyenv}{}{}

\newcommand{\mysection}[1]{
    \addcontentsline{toc}{section}{#1}
    \begin{dummyenv}
        \bfseries\large #1
    \end{dummyenv}
}

\makeatletter
\patchcmd{\l@section}
  {\hfil}
  {\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill}
  {}{}
\makeatother

% Here we go...
\title{БДЗ по прикладной криптографии}
\author{Фирсов Георгий, М21-507}

\begin{document}

\maketitle

\tableofcontents

\pagebreak

\mysection{Задание 1}

Анна генерирует два числа $x \xleftarrow{R} \mathbb{Z}_1, y \xleftarrow{R} \mathbb{Z}_q$, после чего отсылает
Борису тройку $(A_0, A_1, A_2) = (g^x, g^y, g^{xy + a})$.

Борис генерирует свои два числа $r \xleftarrow{R} \mathbb{Z}_q, s \xleftarrow{R} \mathbb{Z}_q$, а затем отправляет
Анне следующую пару: $(B_1, B_2) = (A_1^r \cdot g^s, (A_2/g^b)^r \cdot A_0^s)$. Заметим, что:
\begin{equation*}
    \begin{split}
        & B_1 = A_1^r \cdot g^s = g^y \cdot g^s = g^{\textcolor{red}{y + s}} \\
        & B_2 = (A_2/g^b)^r \cdot A_0^s) = g^{xy + a} \cdot g^{-b} \cdot g^{xs} = g^{x(\textcolor{red}{y + s}) + a - b}
    \end{split}  
\end{equation*}

Если $B_1$ возвести в степень $x$ и затем умножить на обратный к полученному элемент число $B_2$, то получится $g^{a - b}$:
\begin{equation*}
    \begin{split}
        & B_1 ^ x = \left(g^{y + s}\right) ^ x = g^{x(y + s)} \\
        & B_2 \cdot (B_1^{-x}) = g^{x(y + s) + a - b} \cdot g^{-x(y + s)} = g^{a - b}
    \end{split}
\end{equation*}

Если $a = b$, то $g^{a - b} = g^0 = e_{\mathbb{G}}$. Это свойство и можно использовать для проверки равенства чисел $a$ и $b$.

\textbf{Ответ:} в) Анна проверяет равенство $B_2 / B_1^x = 1$.
\\

\mysection{Задание 2}

Так как числа $p, a, b$ общеизвестны, то считаю, что при разработке программы все \textit{возможные} вычисления с данными 
параметрами выполняются заранее (то есть, собственно, на этапе разработки программы). Несложно увидеть, что:
\begin{equation*}
    \begin{split}
        H^{(n)}(x) & = \underbrace{H_{p,a,b}(H_{p,a,b}(\cdots H_{p,a,b}(x) \cdots))}_{\text{n раз}} = 
            \underbrace{a(a(\cdots\ ax + b\ \cdots) + b) + b}_{\text{n раз}} = \\
        & = a^n x + b \sum_{j=0}^{n - 1} a^j \mod p
    \end{split}
\end{equation*}

Обозначим:
\begin{equation*}
    \begin{split}
        & a' := a^n \mod p \\
        & b' := b \sum_{j=0}^{n - 1} a^j \mod p
    \end{split}
\end{equation*}

Тогда:
\begin{equation*}
    H^{(n)}(x) = a'x + b' \mod p
\end{equation*}

Значения $a'$ и $b'$ возможно вычислить предварительно на этапе разработки программы, что позволит вычислять функцию
$H^{(n)}$ так же быстро, как и $H_{p,a,b}$.

Но может случиться так, что числа $p,a,b$ \textit{заранее} не известны (например, меняются с течением времени). 
Таким образом, возникает потребность поддержки вычисления $a', b'$ на лету. В таком случае заметим, что:
\begin{equation*}
    \begin{split}
        \sum_{j=0}^{n-1}a^j = (a^{n-1} - 1) \cdot (a - 1)^{-1} \mod p
    \end{split}
\end{equation*}

При больших $n$ возведение в степень $n-1$ потребует примерно столько же операций, сколько и возведение в степень $n$.
Заметим, что возведение в степень можно производить, пользуясь следующей идеей: $a^4 = a^2 \cdot a^2, 
a^8 = a^4 \cdot a^4$ и т.д. Данный алгоритм требует асимптотически $\log _2(n)$ умножений.

\textbf{Ответ:} а) $H^{(n)}$ может быть вычислена так же быстро, как $H_{p,a,b}$ (в случае известных заранее значений 
$p,a,b$); г) вычисление $H^{(n)}$ требует времени $O(\log n)$ (в случае неизвестных заранее значений $p,a,b$).
\\

\mysection{Задание 3}

Рассмотрим по очереди все варианты, отобрав подходящие:
\begin{itemize}
    \item $p_1 = (k_1, k_2), p_2 = (k_1'), p_3 = (k_2')$: владельцы долей $p_2, p_3$ не смогут вдвоем восстановить
        ключ, так как $k_1' \oplus k_2' =\ ???$.
    
    \item $p_1 = (k_1, k_2), p_2 = (k_2, k_2'), p_3 = (k_2')$: владелец $p_2$ может один восстановить ключ, так как
        $k = k_2 \oplus k_2'$.
    
    \item $p_1 = (k_1, k_2), p_2 = (k_1, k_2), p_3 = (k_2')$: владельцы $p_1, p_2$ не смогут восстановить вдвоем
        ключ, так как никакая комбинация $k_1, k_2$ в сумме не даст $k$.
    
    \item $p_1 = (k_1, k_2), p_2 = (k_1', k_2'), p_3 = (k_2')$: владельцы $p_2, p_3$ не смогут восстановить вдвоем
        ключ, так как никакая комбинация $k_1', k_2'$ в сумме не даст $k$.
        
    \item $p_1 = (k_1, k_2), p_2 = (k_2'), p_3 = (k_1', k_2)$: данный вариант подходит, так как:
        \begin{itemize}
            \item $p_1, p_2$: $k_2  \oplus k_2' = k$
            \item $p_1, p_3$: $k_1  \oplus k_1' = k$
            \item $p_2, p_3$: $k_2' \oplus k_2  = k$
        \end{itemize}
        При этом восстановление ключа ни одним участником единолично невозможно, так как ни один из них не обладает
        двумя частями с одинаковыми индексами.
\end{itemize}
\textbf{Ответ:} д) $p_1 = (k_1, k_2), p_2 = (k_2'), p_3 = (k_1', k_2)$
\\

\mysection{Задание 4}

\mysection{Задание 5}

\begin{enumerate}
    \item Так как каждому участнику $B_i, i \in \{1, ..., n\}$ известен ключ $k$, то, например, $B_2$ может создать 
        некоторое сообщение и рассчитать имитовставку для него с использованием этого ключа. В таком случае участник
        $B_1$, получив сообщение, не может удостовериться, что оно создано участником $A$, а не $B_2$.
\end{enumerate}

\mysection{Задание 6}

Анне и Борису известны следующий величины:
\begin{itemize}
    \item $v$
    \item $u = g^{\alpha} v^{-i}$
    \item Набор $u_j = u v^j = g^{\alpha} v^{j - i}, j \in \{1, ..., n\}$
\end{itemize}

Только Борису известны $\alpha$ и индекс $i$. Заметим, что для $j = i$: $u_i = g^{\alpha}$.

Анна пересылает Борису следующие значения:
\begin{equation*}
    (a_j, b_j) = \left(g^{k_j}, m_j u_j^{k_j}\right), k_j \xleftarrow{R} \{1, 2, ..., q-1\}
\end{equation*}

\begin{enumerate}
    \item \textit{Восстановление сообщения $m_i$ из полученных данных}.
        Борис может расшифровать значение $m_i$ (так как $\alpha$ -- закрытый ключ криптосистемы Эль-Гамаля, соответствующий
        открытому ключу $u_i$):
        \begin{equation*}
            b_i a_i^{-\alpha} = m_i g^{\alpha k_i} g^{-k_i \alpha} = m_i
        \end{equation*}
        
    \item \textit{Невозможность получения индекса $i$ Анной}. Попробовать получить значение $i$ Анна может из значений 
        $u = g^{\alpha} v^{-i}$ и $u_j = g^{\alpha} v^{j-i}$. Так как $v \in \mathbb{G}$, то $v = g^{k}$ для некоторого $k$.
        $u = g^{\alpha - ki}, u_j = g^{\alpha + k(j - i)}$.
        
        Заметим, что Анне неизвестны значения $\alpha, g^{\alpha}$. Отличить $u_i = g^{\alpha}$ (даже если бы он был известен) 
        от какого-то иного элемента группы вычислительно сложно, то есть перебирая $j$ невозможно понять, когда $u_j$ 
        сравняется с $g^{\alpha}$ (то есть при $j = i$).
        
        Получить же $i$ из значения $u$ также вычислительно трудно, так как это предполагает нахождение дискретного логарифма
        (по $u = g^{\alpha - ki}$ найти $\alpha - ki$ трудно).
\end{enumerate}

\mysection{Задание 7}

\mysection{Задание 8}

\mysection{Задание 9}

\mysection{Задание 10}

\begin{enumerate}
    \item \textit{Некорректное хэширование}. Так как требуется подделка подписи для любого сообщения, то рассматривается
        модель стойкости UUF-CMA (Universal Unforgeability under Chosen Message Attack). Рассмотрим противника $\mathcal{A}$,
        действующего по следующему сценарию:
        \begin{itemize}
            \item $\mathcal{A}$ генерирует некоторое сообщение $m \in \mathcal{M}$ (любое).
            
            \item $\mathcal{A}$ вычисляет хэш сообщения: $c = H(m)$.
            
            \item $\mathcal{A}$ вычисляется значение $R = h^{-c}$ ($h = pk$), значение $z$ полагается равным 0.
            
            \item Подпись $\sigma = (R, z) = (pk^{-H(m)}, 0)$ отправляется оракулу проверки подписи.
        \end{itemize}
        
        Заметим, что проверка этой подписи выполнится всегда:
        \begin{equation*}
            \left.\begin{array}{l}
                c \leftarrow H(m) \\
                \textcolor{red}{g^z} = \textcolor{red}{e_{\mathbb{G}}} \\
                \textcolor{red}{R \cdot h^c} = h^{-H(m)} \cdot h^{H(m)} = h^0 = 
                    \textcolor{red}{e_{\mathbb{G}}}
            \end{array}\right\} \implies V(pk, m, \sigma) = \text{accept}
        \end{equation*}
        
        Таким образом:
        \begin{equation*}
            \textbf{Adv}_{\text{SS}}^{\text{UUF-CMA}}(\mathcal{A}) = 
                \text{Pr}[V(pk, m, S(sk, m)) = \text{accept}] = 1
        \end{equation*}
        
    \item \textit{Некорректная генерация случайных чисел}. Обозначим $c_i = H(m_i, R_i), i \in \{0, 1\}$ и, зная, что
        $\rho_1 = a \rho_0 + b$, запишем:
        \begin{equation*}
            \begin{split}
                & \left\{\begin{array}{l}
                    z_0 = \rho_0 + c_0 \alpha \\
                    z_1 = a \rho_0 + b + c_1 \alpha
                \end{array}\right. \\ \\
                & \left\{\begin{array}{l}
                    a z_0 = a \rho_0 + a c_0 \alpha \\
                    z_1 = a \rho_0 + b + c_1 \alpha
                \end{array}\right.
            \end{split}
        \end{equation*}
        
        Тогда:
        \begin{equation*}
            \begin{split}
                & z_1 - a z_0 = b + \alpha (c_1 - a c_0) \\
                & \alpha = (z_1 - a z_0 - b)(c_1 - a c_0)^{-1}
            \end{split}
        \end{equation*}
        
        В общем-то $(c_1 - a c_0)$ -- некоторый случайный элемент из $\mathbb{Z}_q$, а так как $q$ -- простое число,
        то для обратимости элемента требуется только то, чтобы он был ненулевым. Вероятность того, что элемент
        $(c_1 - a c_0)$ обратим, равна:
        \begin{equation*}
            \text{Pr}\left[\begin{array}{c}
                \text{Элемент } (c_1 - a c_0) \\
                \text{обратим в кольце } \mathbb{Z}_q
            \end{array}\right] = 1 - \frac{1}{|\mathbb{Z}_q|} = \frac{q - 1}{q} \xrightarrow[q \to \infty]{} 1
        \end{equation*}
        
    \item \textit{Атака по взаимосвязанным ключам}. Пусть $pk_i = h \cdot g^i = g^{\alpha} \cdot g^i = g^{\alpha + i}$,
        тогда через обозначим $sk_i = \alpha_i = \alpha + i$ (согласно нотации криптосистемы). Введем также обозначение 
        $\Delta\alpha_{ij} := j - i$.
        
        Пусть для некоторого сообщения $m$ имеется некоторая подпись $\sigma_i = (R_i, z_i)$, где $z_i = \rho_i + 
        c_i \alpha_i$, $c_i = H(m, R_i)$. Противник генерирует следующую подпись: $\sigma_j = (R_i, z_j)$, где 
        $z_j = \rho_i + c_i \alpha_i + c_i \Delta\alpha_{ij} = \rho_i + c_i\alpha_j$. 
        
        Эта подпись является валидной 
        для того же сообщения и успешно проверяется на ключе $pk_j$:
        \begin{equation*}
            \left.\begin{array}{l}
                c = H(m, R_i) \\
                g^{z_j} = g^{\rho_i + c_i\alpha_j} = \textcolor{red}{g^{\rho_i + c_i(\alpha + j)}} \\
                R_i \cdot pk_j^{c} = g^{\rho_i} \cdot g^{c(\alpha + j)} = 
                    \textcolor{red}{g^{\rho_i + c(\alpha + j)}}
            \end{array}\right\} \implies V(pk_j, m, \sigma_j) = \text{accept}
        \end{equation*}
\end{enumerate}

\mysection{Задание 11}

\mysection{Задание 12}

\end{document}
